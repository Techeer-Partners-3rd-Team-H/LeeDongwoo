## 스프링 웹 개발 기초

- 정적 컨텐츠
- MVC와 템플릿 엔진
- API

### 정적 컨텐츠

: 파일 그대로 웹브라우저에 전달

<img width="1036" alt="스크린샷 2023-09-25 오후 11 11 14" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/5544290c-644e-451a-ada5-5130807b5297">


- locallhost:8080/hello-static.html → (in spring-boot) tomcat server → 스프링 컨테이너에서 hello-static 관련 컨트롤러를 먼저 찾음/ 없으면 → resources: static/hello-static.html을 찾음

**정적 데이터** : HTML, CSS, img 

- 웹 서버: 정적 데이터만 보내는 서버

**동적 데이터** : 매번 필요할 때마다 다른 데이터를 동적으로 구성, 서버 사이드 프로그래밍

- 웹 애플리케이션(WAS): 동적 데이터를 만들어 보내는 서버, 정적적인 자원들도 처리 할 수 있음

**자바 서버 사이드 프로그래밍**
:서버 사이드 프로그래밍은 서버단에서 웹페이지를 만들어서 보내는 것

- 동시에 여러 요청이 들어온다면 어떻게 처리?
- 서버에 문제가 생기면 이를 어떻게 처리?
- 어떤 방법으로 데이터 전송을 최적화?
- 분산 환경이나 분산 처리와 같은 문제?

---

**Java SE < Java EE ( sevlet, JPA)**

- Java EE를 기반으로 **Tomcat**
    
    <img width="1036" alt="스크린샷 2023-09-09 오후 4 05 25" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/e1e69807-2402-41b0-95c8-4f790404cdd8">

    - 이 중에서 서블릿, JSP는 자바 서버 사이드 프로그래밍에 사용
    - JSP(Java Server Pages): java를 이용한 서버 사이드 템플릿 엔진
    - JSP → Thymeleaf
    
- Spring boot의 Java Web에 Tomcat내장

  <img width="1036" alt="스크린샷 2023-09-09 오후 4 08 48" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/0b93b6cd-c086-4a46-bf11-647b5735d6d7">
  
  <img width="1036" alt="스크린샷 2023-09" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/f2282667-fa73-4514-b760-70e4035e3481">


**서블릿 컨테이너**: 서블릿을 실행할 수 있는 환경

- 객체를 생성하거나 호출함
- 서블릿 클래스에서 생성하는 객체를 관리
- 다음과 같이 서블릿 API에 init(), service(), destroy()로 작성,
서블릿 컨테이너가 관리하면서 호출, 이러한 메소들은 일반적으로 서블릿 라이프 사이클이라고 함.

 <img width="1036" alt="1" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/25dac6a3-ee77-404f-881c-4579b0b2adf2">

- service() → doGet(), doPost()등등

**HttpServlet의 라이프 사이클**

서블릿 클래스들의 처리과정

1. 브라우저가 톰캣에 서블릿이 처리해야 하는 특정한 경로를 호출
2. 톰캣은 해당 경로에 맞는 서블릿 클래스를 로딩하고 객체 생성.
이 과정에서 init()메소드를 실행해서 서블릿 객체가 동작하기 전에 수행해야 하는 일들을 처리
3. 생성된 서블릿 객체는 Request에 대한 정보를 분석해 GET/POST 등의 정보와 함께 같이 전달되는 파라미터(쿼리 스트링의 내용)들을 HttpServletRequest 타입의 파라미터로 전달받음. 이 과정에서 응답을 처리하는 데 필요한 기능들은 HttpServletResponse라는 타입의 객체로 전달받음
4. 서블릿 내부에서는 GET/POST에 맞게 doGet(), doPost()등의 메소드 실행.
이 후 동일한 주소의 호출이 있을 때 서블릿은 동일한 객체 하나만을 이용해서 처리
5. 톰캣이 종료될 때는 서블릿의 destroy()실행

```java
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "sampleServlet", urlPatterns = "/sample")
public class SampleServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws
            ServletException, IOException {
        System.out.println("doGet......" + this);
    }

    @Override
    public void destroy() {
        System.out.println("destroy......");
    }
    @Override
    public void init(ServletConfig config) throws ServletException {
        System.out.println("init(ServletConfig)");
    }

}
```

<img width="1036" alt="스크린샷 2023-09-09 오후 6 08 14" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/a6a3e7fe-78d8-451b-8b26-ac715410317b">

- /sample을 호출하면 init()메소드와 doGet()실행
- 서버 종료하면 destroy()실행
- HttpSevlet클래스에 doGet(), doPost()등 있음.
- init(), destroy()는 한 번씩만 호출되고 doGet(), doPost()는 동일한 객체를 이용해서 여러 번 호출
    - 생성된 Servlet 객체는 메모리에 남겨두어, 동일한 서블릿에 대해 요청이 온다면 기존 객체를 재사용함

## MVC & 템플릿 엔진

- MVC: Model, View, Controller
- View: 화면을 그려주는데 집중
- Model, Controller: 비즈니스 로직, 내부적인 일에 지

<img width="1036" alt="3" src="https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/29aa4175-b6f1-47eb-8fe5-e675ae04b6fd">

```java
import org.springframework.stereotype.Controller;

@Controller
public class HelloController {

    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name); // name이라는 이름으로 name을 넘김
        return "hello-template"; // hello-template.html을 찾아서 렌더링
    }
}
```

```html
<!doctype html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Hello</title>
</head>
<body>
<p th:text="안녕하세요  + ${name}">hello! empty</p>
</body>
</html>
```

[localhost:8080/hello-mvc?name=spring](http://localhost:8080/hello-mvc?name=spring→) → @GetMapping(”hello-mvc”)

→@RequestParam(”name”) = 파라미터에 name=”value” 를 스트링 인자로 전달

→model.addAttribute() = model(name:spring) → return “hello-template” = template/hello-template.html

**@WebServlet = java servlet**

**@Controller = spring MVC**

Spring MVC는 서블릿 위에 구축된 프레임워크 중 하나

Spring MVC의 Controller은 서블릿 위에 구축된 라이브러리

- 모든 요청은 DispatcherServlet에 매핑
    - DispatcherServlet은 어노테이션이 들어오는 요청과 일치하는 컨트롤러를 호출

DispatcherServlet

: HttpServlet을 상속받아 사용하고, 서블릿으로 동작


## API

api : 객체 반환

![4](https://github.com/Techeer-Partners-3rd-Team-H/LeeDongwoo/assets/137749703/7126d983-62b0-4863-b3f4-a86705e63edf)

‘@ResponseBody’

⇒ return에 따라 HttpMessageConverter가 동작

- HTTP의 BODY에 문자 내용을 직접 반환
- viewResolver 대신에 HttpMessageConverter가 동작
- 기본 문자처리: StringHttpMessageConverter
- 기본 객체처리: MappingJackson2 HttpMessageConverter (json으로 바꾸는 library)
- byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음

```java
@Controller
public class HelloController {

    @GetMapping("hello-string")
    @ResponseBody // http의 body에 이 데이터를 직접 넣어주겠다는 의미
    public String helloString(@RequestParam("name") String name) {
        return "hello " + name; // hello name을 렌더링 => "hello spring"
    }

    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello(); // Hello 객체 생성
        hello.setName(name); // name을 넣어줌
        return hello; // json 형태로 반환
    }
    
	//hello 객체에 private name을 public getter setter 메소드를 이용해 조작
    static class Hello {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
```

- http://localhost:8080/hello-api?name=spring!!! 

→@GetMapping(”hello-api”)

→Hello 객체를 반환하는 helloApi()에 @RequestParam(”name”)의 파라미터 값과 String name[파라미터 값을 담을 변수]을 매개변수로 전달

→ Hello 객체를 선언해둔 static class Hello에 맞춰 생성

→ setter로 String name[파라미터 “name”의 값을 담은]을 매개변수로 받아 객체의 private name속성을 변경

→ return hello; : Hello hello객체를 리턴, @ResponseBody를 통해 HttpMessageConverter의 JsonConverter가 Json문자열로 변환하여 HTTP Body로 응답.
